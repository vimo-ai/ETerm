# ETerm 插件系统设计

> 状态：设计讨论中
> 更新：2024-11

## 一、设计背景

ETerm 的核心是终端，但在终端基础上可以有很多扩展可能性。当前已有的两个功能——**划词翻译**和**写作助手**——可以作为插件化的参照案例，用来反推插件系统需要的能力边界。

### 核心理念

- 插件自己管理自己的 UI
- ETerm 提供能力暴露和空间协调
- 基于 Swift 原生协议系统，未来可选加 JS 桥接层

---

## 二、参照案例分析

### 2.1 划词翻译

**用户交互流程：**
1. 用户在终端选中文本
2. 选中结束后，在选区位置显示提示按钮（Popover）
3. 点击按钮，展开翻译窗口（独立 Panel）
4. 单词走词典 + AI 翻译；句子走 AI 分析

**需要的能力：**
- 终端选中事件（文本 + 屏幕坐标）
- 插件自己管理 Popover 和 Panel

### 2.2 写作助手

**用户交互流程：**
1. 用户按 Cmd+K
2. 底部弹出输入框（Overlay）
3. 用户输入英文/中英混合文本
4. AI 分析：语法修复、地道化建议、中英转换
5. 按需加载详细解释

**需要的能力：**
- 快捷键注册（Cmd+K）
- 底部空间预留（Overlay 区域）
- 高度可动态变化

---

## 三、ETerm 提供的能力

### 3.1 终端能力

终端能力通过**事件 + 方法**机制暴露，逐步迭代，需要什么加什么。

#### 事件（插件订阅）

| 事件 | 说明 | 数据 |
|-----|------|------|
| `onSelectionEnd` | 选中结束时触发 | 文本、屏幕坐标、来源视图 |
| `onOutput` | 终端有新输出 | 输出文本（后续按需添加） |

#### 方法（插件主动调用）

| 方法 | 说明 | 返回 |
|-----|------|------|
| `getSelectedText()` | 获取当前选中文本 | String? |
| `getSelection()` | 获取选区详情 | 起止位置、屏幕坐标 |
| `sendText(text)` | 写入终端 | - |
| `getBuffer(lines)` | 读取最近 N 行 | [String]（后续按需添加） |
| `getCurrentDirectory()` | 获取工作目录 | String?（后续按需添加） |

#### 当前优先级（基于参照案例）

| 能力 | 划词翻译 | 写作助手 | 优先级 |
|-----|---------|---------|-------|
| `onSelectionEnd` | ✅ | - | P0 |
| `getSelectedText()` | ✅ | - | P0 |
| 选中位置坐标 | ✅ | - | P0 |
| `sendText()` | - | 可能 | P1 |
| `getBuffer()` | - | - | P2 |
| `onOutput` | - | - | P2 |

### 3.2 命令系统

命令系统是插件功能的统一分发层。所有功能都注册为"命令"，然后通过不同方式触发。

#### 架构

```
┌─────────────────────────────────────────────────────────────┐
│                        触发来源                              │
│                                                              │
│   快捷键    菜单栏    右键菜单    命令面板    插件调用         │
│     │        │         │          │          │              │
│     └────────┴─────────┴──────────┴──────────┘              │
│                        ↓                                     │
│                   命令 ID                                    │
│              "translation.show"                              │
│                        ↓                                     │
│                 命令注册表                                    │
│              (CommandRegistry)                               │
│                        ↓                                     │
│                 执行 Handler                                 │
└─────────────────────────────────────────────────────────────┘
```

#### 命令的组成

| 要素 | 说明 | 示例 |
|-----|------|------|
| ID | 唯一标识，`插件.动作` 格式 | `translation.show` |
| 标题 | 显示名称（命令面板、菜单用） | "显示翻译" |
| Handler | 执行逻辑 | 函数/闭包 |
| 图标 | 可选，菜单/工具栏用 | `sparkles` |

#### 好处

1. **统一入口**：所有功能都是命令，调试方便
2. **用户可配置**：快捷键可自定义，覆盖插件默认
3. **插件互操作**：插件 A 可以调用插件 B 的命令
4. **命令面板**：所有命令可搜索执行（类似 VSCode 的 Cmd+Shift+P）

### 3.3 键盘能力

键盘快捷键通过绑定到命令来工作，而不是直接注册回调。

#### 绑定方式

| 绑定类型 | 说明 |
|---------|------|
| 快捷键 → 命令 | Cmd+K → `writing.showComposer` |
| 菜单项 → 命令 | Tools 菜单 → `writing.showComposer` |
| 右键菜单 → 命令 | 选中文本右键 → `translation.show` |

#### when 条件

参考 VSCode，快捷键可以设置生效条件：

| 条件 | 含义 |
|-----|------|
| `terminalFocus` | 终端有焦点 |
| `hasSelection` | 有选中内容 |
| `config.xxx.enabled` | 用户配置开关 |
| 自定义 context | 插件可设置自己的 context flag |

#### 不需要的能力

基于 VSCode 插件调研，大部分插件只需要简单的快捷键注册，以下能力**不提供**：

- 底层按键 hook（拦截所有按键）
- 拦截 IME 输入
- 复杂的按键序列（如 Vim 模式）

### 3.4 布局能力

插件自己管理 UI，ETerm 提供空间预留和协调。

#### 预留区域

| 区域 | 宽度 | 高度 | 说明 |
|-----|------|------|------|
| 底部 | 默认全宽 | 插件回调上报 | 写作助手 Overlay |
| 顶部 | 默认全宽 | 插件回调上报 | 通知栏等 |
| 左侧 | 必须指定 | 默认填满 | 侧边栏 |
| 右侧 | 必须指定 | 默认填满 | 侧边栏 |

#### 高度自适应机制

```
插件激活时：
  → 告诉 ETerm "我要底部空间"
  → ETerm 给插件一个"上报高度"的回调

插件内容变化时：
  → 调用回调，上报新高度
  → ETerm 重新布局终端区域

插件停用时：
  → 释放预留空间
  → 终端恢复全尺寸
```

#### 多插件同区域

同一区域多个插件需要空间时，采用垂直堆叠策略。

### 3.5 菜单能力

菜单项通过绑定到命令来工作（见 3.2 命令系统）。

| 位置 | 说明 |
|-----|------|
| 菜单栏 | File/Edit/View/Tools/Help 等位置 |
| 右键菜单 | 终端区域、选中文本、Tab 等 |

### 3.6 存储能力

| 能力 | 说明 |
|-----|------|
| 插件私有存储 | 每个插件独立的持久化存储空间 |
| 配置存储 | 用户可配置的选项 |

### 3.7 网络能力

插件自行处理网络请求，ETerm 不做特殊封装。

---

## 四、插件形态

### 4.1 插件协议

每个插件需要实现：
- **Manifest**：ID、名称、版本、权限声明
- **activate**：插件激活时调用
- **deactivate**：插件停用时调用

### 4.2 权限声明

插件需要声明使用的能力：
- 终端读取
- 终端写入
- 终端事件
- 键盘注册
- 布局预留
- 存储
- 网络

### 4.3 协议驱动架构

整个插件系统基于 Swift Protocol 构建，这是核心设计理念。

#### 为什么用协议

- Swift 原生支持，性能最优
- 类型安全，编译时检查
- 易于测试和 Mock
- 未来可扩展多种实现方式

#### 分层结构

```
┌─────────────────────────────────────────────────────────────┐
│                    可选：JS/TS 桥接层                        │
│                  (JavaScriptCore, macOS 原生)                │
│                                                              │
│      JS 插件代码 → 桥接调用 → Swift 协议方法                  │
├─────────────────────────────────────────────────────────────┤
│                    Swift Protocol 层                         │
│                                                              │
│   TerminalService    KeyboardService    LayoutService       │
│   (终端能力协议)       (键盘能力协议)      (布局能力协议)       │
│                                                              │
│            原生插件直接实现协议，零开销                        │
├─────────────────────────────────────────────────────────────┤
│                      ETerm Core                              │
│                                                              │
│   终端渲染 (Sugarloaf)  |  窗口管理  |  键盘系统  |  ...     │
└─────────────────────────────────────────────────────────────┘
```

#### 核心协议

| 协议 | 职责 |
|-----|------|
| CommandService | 命令注册、执行、查询 |
| TerminalService | 终端读取、写入、事件订阅 |
| KeyboardService | 快捷键绑定到命令 |
| LayoutService | 空间预留、布局协调 |
| MenuService | 菜单项绑定到命令 |
| StorageService | 持久化存储 |

#### 协议的好处

1. **先定义契约**：协议定义清楚后，实现可以逐步完善
2. **多种接入方式**：原生 Bundle 直接实现；JS 通过桥接实现
3. **性能分层**：原生插件零开销；JS 插件有桥接开销但仍然很快（底层还是 Swift）
4. **AI 友好**：类型系统帮助 AI 生成正确的插件代码

### 4.4 技术路线

**第一阶段：Swift 原生 Bundle**
- 性能最优
- 完整 API 访问
- 需要签名

**第二阶段（可选）：JS 桥接层**
- 在 Swift 协议层之上加 JavaScriptCore 桥接
- 支持 TypeScript 开发（本地编译为 JS）
- 底层仍走 Swift 协议，性能好

---

## 五、插件 UI 位置示意

```
┌─────────────────────────────────────────────────────────────┐
│  顶部预留区域（如果有插件需要）                                │
├─────────────────────────────────────────────────────────────┤
│  Page Bar                                                    │
├─────────┬───────────────────────────────────────┬───────────┤
│         │                                       │           │
│  左侧   │                                       │   右侧    │
│  预留   │         终端渲染区域                   │   预留    │
│         │        （自动调整大小）                │           │
│         │                                       │           │
│         │                                       │           │
├─────────┴───────────────────────────────────────┴───────────┤
│  底部预留区域（写作助手 Overlay 等）                          │
└─────────────────────────────────────────────────────────────┘

独立 Panel（如翻译详情窗口）：
  - 由插件自己创建和管理
  - 不占用终端布局空间
  - 可拖拽、可关闭
```

---

## 六、待讨论问题

- [ ] 插件之间的通信机制？
- [ ] 内置插件 vs 可卸载插件？
- [ ] UI 样式一致性要求？
- [ ] 插件配置界面统一管理还是各自管理？
- [ ] 插件市场和分发机制？
- [ ] 签名和审核流程？

---

## 七、参考

- 现有划词翻译实现：`TranslationPanel.swift`, `BubbleState.swift`, `DictionaryService.swift`
- 现有写作助手实现：`InlineComposerView.swift`, `OllamaService.swift`
- 键盘系统：`KeyboardEventPipeline.swift`, `KeyboardSystem.swift`
